<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>数理习题动画展示</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }
        #animationContainer {
            width: 800px;
            height: 500px;
            border: 1px solid #ccc;
            background-color: #fff;
            position: relative; /* For absolute positioning of explanation */
        }
        svg {
            width: 100%;
            height: 100%;
        }
        .controls {
            margin-top: 20px;
        }
        button {
            padding: 10px 15px;
            font-size: 16px;
            margin: 0 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        #explanation {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            text-align: center;
        }
        /* Basic styling for SVG elements - can be enhanced */
        rect {
            stroke: #333;
            stroke-width: 1;
            transition: all 0.5s ease-in-out;
        }
        text {
            font-size: 18px;
            fill: #000;
            text-anchor: middle;
            dominant-baseline: middle;
            transition: all 0.5s ease-in-out;
            pointer-events: none; /* So they don't interfere with rect clicks if any */
        }
        .highlight {
            stroke: red;
            stroke-width: 3;
        }
        .fade-out {
            opacity: 0;
        }
        .fade-in {
            opacity: 1;
        }
    </style>
</head>
<body>
    <h1>数理习题动画展示</h1>
    <div id="animationContainer">
        <svg id="drawingCanvas"></svg>
        <div id="explanation">请点击“下一步”开始。</div>
    </div>
    <div class="controls">
        <button id="prevBtn" disabled>上一步</button>
        <button id="nextBtn">下一步</button>
        <button id="resetBtn">重置</button>
    </div>

    <script>
        const svgNS = "http://www.w3.org/2000/svg";
        const canvas = document.getElementById('drawingCanvas');
        const explanationDiv = document.getElementById('explanation');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const resetBtn = document.getElementById('resetBtn');

        let currentStep = -1;
        const rectHeight = 40;
        const unitWidth = 30; // 每个单位数值对应的宽度
        const startY1 = 80;
        const startY2 = 180;
        const startX = 50;

        // 存储每一步的状态或操作
        const steps = [
            // Step 0: 初始状态，九和十六用两个长方形表示
            () => {
                clearCanvas();
                explanationDiv.textContent = "九和十六用两个长方形表示。";
                
                const rect9 = createRect(startX, startY1, 9 * unitWidth, rectHeight, 'skyblue', 'rect9');
                const text9 = createText(startX + (9 * unitWidth) / 2, startY1 + rectHeight / 2, '9', 'text9');
                canvas.appendChild(rect9);
                canvas.appendChild(text9);

                const rect16 = createRect(startX, startY2, 16 * unitWidth, rectHeight, 'lightgreen', 'rect16');
                const text16 = createText(startX + (16 * unitWidth) / 2, startY2 + rectHeight / 2, '16', 'text16');
                canvas.appendChild(rect16);
                canvas.appendChild(text16);
            },
            // Step 1: 把十六一分为二，这部分就是九，这部分就是七
            () => {
                explanationDiv.textContent = "把十六一分为二，这部分是九，另一部分是七。";
                const oldRect16 = document.getElementById('rect16');
                const oldText16 = document.getElementById('text16');
                if (oldRect16) oldRect16.classList.add('fade-out');
                if (oldText16) oldText16.classList.add('fade-out');

                setTimeout(() => {
                    if (oldRect16) oldRect16.remove();
                    if (oldText16) oldText16.remove();

                    const rect16_9 = createRect(startX, startY2, 9 * unitWidth, rectHeight, 'lightgreen', 'rect16_9');
                    const text16_9 = createText(startX + (9 * unitWidth) / 2, startY2 + rectHeight / 2, '9', 'text16_9');
                    
                    const rect16_7 = createRect(startX + 9 * unitWidth, startY2, 7 * unitWidth, rectHeight, 'salmon', 'rect16_7');
                    const text16_7 = createText(startX + 9 * unitWidth + (7 * unitWidth) / 2, startY2 + rectHeight / 2, '7', 'text16_7');
                    
                    canvas.appendChild(rect16_9);
                    canvas.appendChild(text16_9);
                    canvas.appendChild(rect16_7);
                    canvas.appendChild(text16_7);

                    [rect16_9, text16_9, rect16_7, text16_7].forEach(el => {
                        el.classList.add('fade-in');
                    });

                }, 500); // Wait for fade out
            },
            // Step 2: 同时与元相加，就是在蓝色的基础上同时加上相同的一部分 (元)。
            () => {
                explanationDiv.textContent = "引入未知数“元”。将“元”分别加到9和16上。";
                
                // 元 + 9
                const rectYuan1 = createRect(startX - 5 * unitWidth, startY1, 5 * unitWidth, rectHeight, 'orange', 'rectYuan1');
                const textYuan1 = createText(startX - (5 * unitWidth) / 2, startY1 + rectHeight / 2, '元', 'textYuan1');
                canvas.appendChild(rectYuan1);
                canvas.appendChild(textYuan1);
                [rectYuan1, textYuan1].forEach(el => el.classList.add('fade-in'));


                // 元 + 16 (由元 + 9 + 7 组成)
                const rectYuan2 = createRect(startX - 5 * unitWidth, startY2, 5 * unitWidth, rectHeight, 'orange', 'rectYuan2');
                const textYuan2 = createText(startX - (5 * unitWidth) / 2, startY2 + rectHeight / 2, '元', 'textYuan2');
                canvas.appendChild(rectYuan2);
                canvas.appendChild(textYuan2);
                [rectYuan2, textYuan2].forEach(el => el.classList.add('fade-in'));

                // Move existing elements to make space if needed - for simplicity, we assume positions are fine
            },
            // Step 3: 表示元加九对应二（份），元加十六对应三（份）。
            () => {
                explanationDiv.textContent = "元+9 对应两份，元+16 对应三份。";
                const yuan1_endX = startX - 5 * unitWidth + 5 * unitWidth + 9 * unitWidth; // End of 元+9
                const textRatio2 = createText(yuan1_endX + 50, startY1 + rectHeight / 2, '→ 2份', 'textRatio2');
                canvas.appendChild(textRatio2);
                textRatio2.classList.add('fade-in');

                const yuan2_endX = startX - 5 * unitWidth + 5 * unitWidth + 16 * unitWidth; // End of 元+16
                const textRatio3 = createText(yuan2_endX + 50, startY2 + rectHeight / 2, '→ 3份', 'textRatio3');
                canvas.appendChild(textRatio3);
                textRatio3.classList.add('fade-in');
            },
            // Step 4: 这里就是一份，一份是七。
            () => {
                explanationDiv.textContent = "上下两组的差是 (元+16) - (元+9) = 7。 这也对应 (3份 - 2份) = 1份。所以1份是7。";
                
                // Highlight the difference (the '7' part of 16)
                const rect16_7 = document.getElementById('rect16_7');
                if(rect16_7) rect16_7.classList.add('highlight');
                
                const textOnePartIsSeven = createText(startX + 9 * unitWidth + (7 * unitWidth) / 2, startY2 + rectHeight + 30, '1份 = 7', 'textOnePartIsSeven');
                textOnePartIsSeven.style.fill = "red";
                textOnePartIsSeven.style.fontWeight = "bold";
                canvas.appendChild(textOnePartIsSeven);
                textOnePartIsSeven.classList.add('fade-in');
            },
            // Step 5: 两份就是十四。
            () => {
                explanationDiv.textContent = "因为1份是7，所以2份就是 2 * 7 = 14。";
                const textTwoPartsIsFourteen = createText(startX + 9 * unitWidth + (7 * unitWidth) / 2, startY2 + rectHeight + 60, '2份 = 14', 'textTwoPartsIsFourteen');
                textTwoPartsIsFourteen.style.fill = "blue";
                textTwoPartsIsFourteen.style.fontWeight = "bold";
                canvas.appendChild(textTwoPartsIsFourteen);
                textTwoPartsIsFourteen.classList.add('fade-in');

                // Optionally, update the "2份" text near 元+9
                const textRatio2 = document.getElementById('textRatio2');
                if (textRatio2) textRatio2.textContent = '→ 2份 = 14';
            },
            // Step 6: 这里就是十四减九等于五。元+9 = 14，所以 元 = 14 - 9 = 5
            () => {
                explanationDiv.textContent = "元+9 对应2份，也就是14。所以 元 + 9 = 14。 因此 元 = 14 - 9 = 5。";
                
                // Highlight 元+9 part
                ['rectYuan1', 'rect9'].forEach(id => {
                    const el = document.getElementById(id);
                    if(el) el.classList.add('highlight');
                });

                const textYuanPlus9is14 = createText(startX + 2 * unitWidth, startY1 - 30, '元 + 9 = 14', 'textYuanPlus9is14');
                canvas.appendChild(textYuanPlus9is14);
                textYuanPlus9is14.classList.add('fade-in');

                const textYuanIs5Calc = createText(startX + 2 * unitWidth, startY1 - 60, '元 = 14 - 9 = 5', 'textYuanIs5Calc');
                textYuanIs5Calc.style.fill = "green";
                textYuanIs5Calc.style.fontWeight = "bold";
                canvas.appendChild(textYuanIs5Calc);
                textYuanIs5Calc.classList.add('fade-in');
            },
            // Step 7: 这里也就是五，五就是最终答案。
            () => {
                explanationDiv.textContent = "所以，“元”的值是5。这就是最终答案！";
                // Update "元" text to "5"
                ['textYuan1', 'textYuan2'].forEach(id => {
                    const el = document.getElementById(id);
                    if (el) {
                        el.textContent = '5';
                        el.style.fill = "green";
                        el.style.fontWeight = "bold";
                        el.classList.add('highlight'); // Highlight the final answer
                    }
                });
                ['rectYuan1', 'rectYuan2'].forEach(id => {
                     const el = document.getElementById(id);
                     if(el) el.classList.add('highlight');
                });

                const finalAnswerText = createText(canvas.width.baseVal.value / 2, canvas.height.baseVal.value - 60, '最终答案: 元 = 5', 'finalAnswerText');
                finalAnswerText.style.fontSize = "24px";
                finalAnswerText.style.fill = "purple";
                finalAnswerText.style.fontWeight = "bold";
                canvas.appendChild(finalAnswerText);
                finalAnswerText.classList.add('fade-in');
            }
        ];

        function createRect(x, y, width, height, fill, id) {
            const rect = document.createElementNS(svgNS, 'rect');
            rect.setAttribute('x', x);
            rect.setAttribute('y', y);
            rect.setAttribute('width', width);
            rect.setAttribute('height', height);
            rect.setAttribute('fill', fill);
            if (id) rect.setAttribute('id', id);
            rect.style.opacity = 0; // Start invisible for fade-in
            return rect;
        }

        function createText(x, y, content, id) {
            const text = document.createElementNS(svgNS, 'text');
            text.setAttribute('x', x);
            text.setAttribute('y', y);
            text.textContent = content;
            if (id) text.setAttribute('id', id);
            text.style.opacity = 0; // Start invisible for fade-in
            return text;
        }

        function clearCanvas() {
            while (canvas.firstChild) {
                canvas.removeChild(canvas.firstChild);
            }
        }

        function updateButtons() {
            prevBtn.disabled = currentStep <= 0;
            nextBtn.disabled = currentStep >= steps.length - 1;
        }
        
        function executeStep(stepIndex) {
            if (stepIndex >= 0 && stepIndex < steps.length) {
                // Clear highlights from previous step elements that might not be targeted in current
                // A more robust way would be to manage highlights explicitly per step
                document.querySelectorAll('.highlight').forEach(el => el.classList.remove('highlight'));
                
                steps[stepIndex]();
            }
            updateButtons();
        }

        function runNextStep() {
            if (currentStep < steps.length - 1) {
                currentStep++;
                // If going forward, just execute the current step.
                // The step function itself should handle adding elements.
                // For a true "undo" on prev, we'd need to store state or be able to reverse actions.
                // This simple version will re-render up to the point.
                // For a simpler "next only" or full re-render on prev:
                clearCanvas(); // Clear and re-render all previous steps up to current
                for (let i = 0; i <= currentStep; i++) {
                     // Temporarily hide explanation updates for past steps when redrawing
                    const originalTextContent = explanationDiv.textContent;
                    const originalFunc = steps[i];
                    steps[i] = () => { // Wrapper to suppress explanation for past steps
                        const tempExplanation = explanationDiv.textContent;
                        originalFunc();
                        if (i < currentStep) explanationDiv.textContent = tempExplanation; // Restore if not current
                    };
                    steps[i]();
                    steps[i] = originalFunc; // Restore original function
                }
            }
            updateButtons();
        }
        
        function runPrevStep() {
            if (currentStep > 0) {
                currentStep--;
                clearCanvas(); // Clear and re-render all previous steps up to current
                for (let i = 0; i <= currentStep; i++) {
                    const originalTextContent = explanationDiv.textContent;
                    const originalFunc = steps[i];
                    steps[i] = () => {
                        const tempExplanation = explanationDiv.textContent;
                        originalFunc();
                        if (i < currentStep) explanationDiv.textContent = tempExplanation;
                    };
                    steps[i]();
                    steps[i] = originalFunc;
                }
            }
            updateButtons();
        }


        nextBtn.addEventListener('click', runNextStep);
        prevBtn.addEventListener('click', runPrevStep);
        resetBtn.addEventListener('click', () => {
            currentStep = -1;
            runNextStep(); // This will effectively run step 0
        });

        // Initialize
        runNextStep(); // Start with the first step (index 0)

    </script>
</body>
</html>